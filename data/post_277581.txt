Author: Raphael Gaschignard
Created at: 2025-11-18 04:22
Number: 61
Clean content: corona10: @emmatyping What I’m curious about is this: in the current PoC, most of the code uses unsafe blocks. I understand this isn’t Rust’s fault but rather a limitation of the CPython API. Still, how do these modules become memory-safe in the PoC, and how much less do we need to worry about memory safety compared to writing the same code in C? For example, if you could say something like “X% of the code in the base64 module becomes memory-safe,” that would be a helpful metric to highlight. To expand on this point, I see Rust as a potential usability gain here, much more than the security aspect. I think the argument to use Rust for CPython here would be much stronger if we could see standard_b64encode implemented in a way that takes advantage of Rust’s RAII to reduce the book-keeping we have to do in the C code right now. Without a “Rust API” here for writing these extensions, this becomes purely a security argument (that I find fairly unconvincing at some level). If standard_b64encode was returning a Result and we were able to use ? and all this other stuff with a wrapper that did “the right thing” that would be, at least to me, much more interesting EDIT: though a point against this being easy might be the memory allocation story here… though the error allocation failure paths are about allocation failures in the Python arena, not sure if that means we really have no stack left over. Still think it’s worth proving the point that this has ergonomics improvements, because that feels like a pretty big deal all things considered!
