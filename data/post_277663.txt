Author: Michael H
Created at: 2025-11-18 17:20
Number: 99
Clean content: I have too many concerns about the use of Python in various bootstrapping to be in favor of this currently. I agree with the overall goal of increasing memory safety and making it easier to write code people can be confident in by default, and I like Rust for this, but I don’t see this as the right move without more supporting pieces that just aren’t there yet when considering how Python is used in the world. It seems more advantageous to focus on which modules have both C and Python implementations that would highly benefit from the guarantees afforded. This also seems to have cleaner boundaries on a technical level, and doesn’t force people to evaluate Rust adoption as an all-or-nothing roadmap to be committed to before it is proven to work within CPython’s core development, and before seeing actual impact of even that smaller transition. It’s also worth pointing out that there are options other than rust which have stronger formal guarantees than C (some more than Rust), and which don’t require a Rust toolchain. Python is already using GitHub - hacl-star/hacl-star: HACL*, a formally verified cryptographic library written in F* for various cryptography functions, and getting more from doing so than had a Rust implementation been chosen: The code for all of these algorithms is formally verified using the F* verification framework for memory safety, functional correctness, and secret independence (resistance to some types of timing side-channels). While Rust is certainly more popular than a purpose-chosen subset of F* [1] , it serves as a point that it is possible to get the level of additional compiler-enforced safety that’s desired without compromising on the existing portability of CPython. As CPython doesn’t support these unsupported triples either, Rust stabilizing user-provided JSON targets brings it to effective parity: “You’re on your own, but the build tools required have a stable way of doing it.” I also want to be crystal clear, I don’t think it’s even remotely feasible to say “Rust has to support all target triples that have ever used or ever will use python.” There’s a limited amount of maintainer bandwidth in every project, and some hardware just isn’t being developed for by the core teams. It’s niche. A probably less important issue, but one that I think hasn’t been mentioned directly [2] , is that rust and rust-analyzer both use significantly more memory than existing tooling for C. I don’t think it’s an amount likely to be a significant contribution barrier, and don’t personally count this against the proposal, but would like to make sure all known impacts are considered. Low* ↩︎ Compile times were mentioned, but there’s workflows that avoid the brunt of this. ↩︎
