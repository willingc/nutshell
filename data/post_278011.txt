Author: Jeong, YunWon
Created at: 2025-11-21 01:50
Number: 189
Clean content: nas: array bounds checking: in the year 2025, it’s crazy we are using a programming language that doesn’t do this. Yes, there can be extra overhead. No, you are not smart enough to get it correct. use-after-free and other memory lifetime bugs. Rust’s borrow checker avoids most of these at compile time. integer overflow: Rust doesn’t prevent it but at least it defines what happens. Undefined behavior is bad. scope based cleanup: I’ve heard that the C language standard might eventually be getting something like __attribute__((cleanup(...))) . It’s probably going to be decades before CPython could actually rely on C compilers supporting that. This pattern comes up so often and it’s painful we don’t have a built-in language feature that supports it. Adding more details about the points. array bounds checking is on by default, but when the overhead matters, explicitly skipping check is possible for each element access.. integer overflow panics on debug build. it has both checked operation and wrapping operation. checked operation is default on debug build. wrapping operation is default on release build. Of course each operation can be explicitly marked as checked if it is useful for runtime. Otherwise explicitly marking as wrapping is also useful when it is intended.
