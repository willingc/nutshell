Author: Filipe Laíns
Created at: 2025-11-19 02:32
Number: 127
Clean content: Hi, thank you for being willing to take on this project! The proposal overall seems great, with the proposal scope and bootstrapping story being the only potentially major issues I see. I am only gonna comment on that, as other folks are already addressing remaining concerns. This discussion is already big as-is, and I have no doubt it will still grow much larger Proposal scope Unless I am misinterpreting it, the proposal foreword seems to imply that this is a phased proposal that will eventually add Rust as a required build dependency of CPython, but the presented PEP only covers making it an optional build dependency. This proposal declares Rust will at some point will stop being optional. While I understand the motivation, I feel like deciding this right now is too early. I don’t think the PEP provides strong enough supporting evidence to outweigh the potential implications of such a major change. The downstream impact is still pretty up in the air, as is the impact on development, etc., while the potential benefit of introducing Rust into the core code-base is still very unclear. When I say the benefit of using Rust in core is unclear, I am not questioning Rust’s benefit over C. It’s the quantity of opportunities where it would make sense to use it that is unclear. I strongly believe we should not be rewriting existing code in Rust without a specific reason, and that’s what I think is unclear at this point. Even the PEP is unsure of the timeline for promoting Rust to a hard build dependency, probably because of this. I think this proposal would be much easier to drive forward if it were split into two phases, each with its own PEP. Introducing Rust as an optional build dependency Promoting Rust to a hard build dependency This way, 1) would allow us to gather feedback from the development team, downstreams, etc., giving us a much better picture of the impact of 2), enabling us to make a better argument and design a more concrete plan. With this in mind, here are my suggestions for the PEP text: Add an “Abstract“ section explaining that the PEP is a first step into the adoption of Rust in the CPython codebase, introducing it in an optional capacity, allowing us to experiment, gather developer feedback, and better assess the technical implications of using Rust in CPython. Add a “Goals“ section Explicitly state that rewriting existing code in Rust without further motivation is a non-goal Define a couple of goals, like the following Evaluate how well the development team engages with Rust inside the codebase Evaluate how well the CPython architecture couples with Rust Evaluate the impact of first-party Rust APIs on downstream users (eg. PyO3) Gather feedback from downstream users regarding the bootstrapping implications Gather feedback from downstream users of platforms where Rust is not supported Add a “Future“ section explaining that, contingent on the impact of this PEP, we plan to promote Rust to a hard build dependency as a next step Remove “Keep Rust Always-Optional“ from “Rejected Ideas” TLDR I don’t feel the PEP provides enough justification to make Rust a hard build dependency, and I think that’s something that would be difficult to provide at this point. As such, I feel like this proposal would be better served by splitting into two phases/PEP — starting with adding Rust as an optional build dependency, and then promoting it into a hard build dependency. Bootstrapping I personally don’t think any of the given solutions are good enough at the moment, so it is very important to explore other options. IMO, even if no better solutions are found, the PEP authors should show they have exhausted all other sensible possibilities. That said, I may be mistaken, but it’s my understanding that Python should only be needed to build LLVM for rustc . Perhaps it would be worth exploring the possibility of using the Cranelift backend instead, which AFAICT doesn’t need Python. It may also be worthwhile to engage with the mrustc project, as they may have better insights on other possible approaches. Another thing that I thought it would be pertinent to point out. If we were to introduce Python to the bootstrapping dependency tree (via Rust), that would greatly weaken the argument against moving CPython’s build system to Meson (discussion in What do you want to see in tomorrow’s CPython build system? ).
