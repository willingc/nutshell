Author: Stephan Sokolow
Created at: 2025-11-18 18:22
Number: 106
Clean content: Generally speaking, standardization tends to come into play for one of two purposes: Re-unifying disparate implementations of a language (C, C++, ECMAScript, etc.) Making a proprietary product look more appealing to enterprise or government decision-makers (Java, .NET, Office Open XML, etc.) Given that Rust’s regression suite and v1.0 stability promise already pin the language down more thoroughly than C or C++ and that gccrs plans to follow rustc as the source of truth, I’m not sure a standard would have much benefit here. (Seriously. Look into how much about C is left implementation-defined. We generally greatly overestimate what the spec actually calls for. That’s one reason you tend to see big projects picking one or maybe two compilers per platform and coding against those. For example, the Linux kernel is written in GNU C and the ability to compile it using llvm-clang was a little bit about retiring use of features the kernel devs had decided were mistakes and overwhelmingly about teaching llvm-clang to support GNU C. …it also has its own non-standard memory model that only works because GCC is careful not to break it.)
