Author: Paul Moore
Created at: 2025-11-20 20:51
Number: 174
Clean content: Jelle Zijlstra: My thoughts are that a proposal that allows Rust only for optional extension modules is likely not useful enough to justify the cost of adding a new language. There’s been a number of comments about “optional extension modules” in this discussion so far. I want to make sure we’re 100% clear on what we mean by this, as I’m concerned we could end up measuring the wrong thing otherwise. As an end user, I have literally no interest in what language a stdlib module (or a core feature) is written in. It’s irrelevant to me. However, I have a strong interest in what is available in the stdlib and core. Optional modules are an awkward compromise here - can I use the module safely, or do I need to account for the possibility that it might not be available? This is exacerbated by the fact that the packaging ecosystem has no way to express a dependency on “Python >= 3.13, with the tkinter module available” (for example). If we introduce Rust by using it for stdlib modules, and as a result make them (and anything that depends on them!) optional, then we risk getting negative feedback which will look like it’s a downside of Rust, when it’s actually a downside of optional modules. I think the intention is not to do this, but rather to use Rust to create accelerators for existing pure-Python modules. But if that is the case, can we be clearer about this, so that people don’t get the wrong impression? Assuming we are talking about accelerators, I feel that @Jelle has a point. Using Rust to get a faster JSON module [1] will be a good way of finding out what’s involved in adding Rust to the core build process, but I don’t think it will provide much useful feedback on whether Rust provides sufficient benefit to be worth taking further. Which prompts the question - what would useful feedback look like? And how do we get it? I don’t think that’s been clearly established yet. I have to say that I don’t think anyone cares about a faster base64 module… ↩︎
